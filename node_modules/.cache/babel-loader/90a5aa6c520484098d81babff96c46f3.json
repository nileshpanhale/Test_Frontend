{"ast":null,"code":"'use strict';\n\nvar base32 = require('base32.js');\n\nvar crypto = require('crypto');\n\nvar url = require('url');\n\nvar util = require('util');\n/**\n * Digest the one-time passcode options.\n *\n * @param {Object} options\n * @param {String} options.secret Shared secret key\n * @param {Integer} options.counter Counter value\n * @param {String} [options.encoding=\"ascii\"] Key encoding (ascii, hex,\n *   base32, base64).\n * @param {String} [options.algorithm=\"sha1\"] Hash algorithm (sha1, sha256,\n *   sha512).\n * @param {String} [options.key] (DEPRECATED. Use `secret` instead.)\n *   Shared secret key\n * @return {Buffer} The one-time passcode as a buffer.\n */\n\n\nexports.digest = function digest(options) {\n  var i; // unpack options\n\n  var secret = options.secret;\n  var counter = options.counter;\n  var encoding = options.encoding || 'ascii';\n  var algorithm = (options.algorithm || 'sha1').toLowerCase(); // Backwards compatibility - deprecated\n\n  if (options.key != null) {\n    console.warn('Speakeasy - Deprecation Notice - Specifying the secret using `key` is no longer supported. Use `secret` instead.');\n    secret = options.key;\n  } // convert secret to buffer\n\n\n  if (!Buffer.isBuffer(secret)) {\n    if (encoding === 'base32') {\n      secret = base32.decode(secret);\n    }\n\n    secret = new Buffer(secret, encoding);\n  }\n\n  var secret_buffer_size;\n\n  if (algorithm === 'sha1') {\n    secret_buffer_size = 20; // 20 bytes\n  } else if (algorithm === 'sha256') {\n    secret_buffer_size = 32; // 32 bytes\n  } else if (algorithm === 'sha512') {\n    secret_buffer_size = 64; // 64 bytes\n  } else {\n    console.warn('Speakeasy - The algorithm provided (`' + algorithm + '`) is not officially supported, results may be different than expected.');\n  } // The secret for sha1, sha256 and sha512 needs to be a fixed number of bytes for the one-time-password to be calculated correctly\n  // Pad the buffer to the correct size be repeating the secret to the desired length\n\n\n  if (secret_buffer_size && secret.length !== secret_buffer_size) {\n    secret = new Buffer(Array(Math.ceil(secret_buffer_size / secret.length) + 1).join(secret.toString('hex')), 'hex').slice(0, secret_buffer_size);\n  } // create an buffer from the counter\n\n\n  var buf = new Buffer(8);\n  var tmp = counter;\n\n  for (i = 0; i < 8; i++) {\n    // mask 0xff over number to get last 8\n    buf[7 - i] = tmp & 0xff; // shift 8 and get ready to loop over the next batch of 8\n\n    tmp = tmp >> 8;\n  } // init hmac with the key\n\n\n  var hmac = crypto.createHmac(algorithm, secret); // update hmac with the counter\n\n  hmac.update(buf); // return the digest\n\n  return hmac.digest();\n};\n/**\n * Generate a counter-based one-time token. Specify the key and counter, and\n * receive the one-time password for that counter position as a string. You can\n * also specify a token length, as well as the encoding (ASCII, hexadecimal, or\n * base32) and the hashing algorithm to use (SHA1, SHA256, SHA512).\n *\n * @param {Object} options\n * @param {String} options.secret Shared secret key\n * @param {Integer} options.counter Counter value\n * @param {Buffer} [options.digest] Digest, automatically generated by default\n * @param {Integer} [options.digits=6] The number of digits for the one-time\n *   passcode.\n * @param {String} [options.encoding=\"ascii\"] Key encoding (ascii, hex,\n *   base32, base64).\n * @param {String} [options.algorithm=\"sha1\"] Hash algorithm (sha1, sha256,\n *   sha512).\n * @param {String} [options.key] (DEPRECATED. Use `secret` instead.)\n *   Shared secret key\n * @param {Integer} [options.length=6] (DEPRECATED. Use `digits` instead.) The\n *   number of digits for the one-time passcode.\n * @return {String} The one-time passcode.\n */\n\n\nexports.hotp = function hotpGenerate(options) {\n  // verify secret and counter exists\n  var secret = options.secret;\n  var key = options.key;\n  var counter = options.counter;\n\n  if (key === null || typeof key === 'undefined') {\n    if (secret === null || typeof secret === 'undefined') {\n      throw new Error('Speakeasy - hotp - Missing secret');\n    }\n  }\n\n  if (counter === null || typeof counter === 'undefined') {\n    throw new Error('Speakeasy - hotp - Missing counter');\n  } // unpack digits\n  // backward compatibility: `length` is also accepted here, but deprecated\n\n\n  var digits = (options.digits != null ? options.digits : options.length) || 6;\n  if (options.length != null) console.warn('Speakeasy - Deprecation Notice - Specifying token digits using `length` is no longer supported. Use `digits` instead.'); // digest the options\n\n  var digest = options.digest || exports.digest(options); // compute HOTP offset\n\n  var offset = digest[digest.length - 1] & 0xf; // calculate binary code (RFC4226 5.4)\n\n  var code = (digest[offset] & 0x7f) << 24 | (digest[offset + 1] & 0xff) << 16 | (digest[offset + 2] & 0xff) << 8 | digest[offset + 3] & 0xff; // left-pad code\n\n  code = new Array(digits + 1).join('0') + code.toString(10); // return length number off digits\n\n  return code.substr(-digits);\n}; // Alias counter() for hotp()\n\n\nexports.counter = exports.hotp;\n/**\n * Verify a counter-based one-time token against the secret and return the delta.\n * By default, it verifies the token at the given counter value, with no leeway\n * (no look-ahead or look-behind). A token validated at the current counter value\n * will have a delta of 0.\n *\n * You can specify a window to add more leeway to the verification process.\n * Setting the window param will check for the token at the given counter value\n * as well as `window` tokens ahead (one-sided window). See param for more info.\n *\n * `verifyDelta()` will return the delta between the counter value of the token\n * and the given counter value. For example, if given a counter 5 and a window\n * 10, `verifyDelta()` will look at tokens from 5 to 15, inclusive. If it finds\n * it at counter position 7, it will return `{ delta: 2 }`.\n *\n * @param {Object} options\n * @param {String} options.secret Shared secret key\n * @param {String} options.token Passcode to validate\n * @param {Integer} options.counter Counter value. This should be stored by\n *   the application and must be incremented for each request.\n * @param {Integer} [options.digits=6] The number of digits for the one-time\n *   passcode.\n * @param {Integer} [options.window=0] The allowable margin for the counter.\n *   The function will check \"W\" codes in the future against the provided\n *   passcode, e.g. if W = 10, and C = 5, this function will check the\n *   passcode against all One Time Passcodes between 5 and 15, inclusive.\n * @param {String} [options.encoding=\"ascii\"] Key encoding (ascii, hex,\n *   base32, base64).\n * @param {String} [options.algorithm=\"sha1\"] Hash algorithm (sha1, sha256,\n *   sha512).\n * @return {Object} On success, returns an object with the counter\n *   difference between the client and the server as the `delta` property (i.e.\n *   `{ delta: 0 }`).\n * @method hotp․verifyDelta\n * @global\n */\n\nexports.hotp.verifyDelta = function hotpVerifyDelta(options) {\n  var i; // shadow options\n\n  options = Object.create(options); // verify secret and token exist\n\n  var secret = options.secret;\n  var token = options.token;\n  if (secret === null || typeof secret === 'undefined') throw new Error('Speakeasy - hotp.verifyDelta - Missing secret');\n  if (token === null || typeof token === 'undefined') throw new Error('Speakeasy - hotp.verifyDelta - Missing token'); // unpack options\n\n  var token = String(options.token);\n  var digits = parseInt(options.digits, 10) || 6;\n  var window = parseInt(options.window, 10) || 0;\n  var counter = parseInt(options.counter, 10) || 0; // fail if token is not of correct length\n\n  if (token.length !== digits) {\n    return;\n  } // parse token to integer\n\n\n  token = parseInt(token, 10); // fail if token is NA\n\n  if (isNaN(token)) {\n    return;\n  } // loop from C to C + W inclusive\n\n\n  for (i = counter; i <= counter + window; ++i) {\n    options.counter = i; // domain-specific constant-time comparison for integer codes\n\n    if (parseInt(exports.hotp(options), 10) === token) {\n      // found a matching code, return delta\n      return {\n        delta: i - counter\n      };\n    }\n  } // no codes have matched\n\n};\n/**\n * Verify a counter-based one-time token against the secret and return true if\n * it verifies. Helper function for `hotp.verifyDelta()`` that returns a boolean\n * instead of an object. For more on how to use a window with this, see\n * {@link hotp.verifyDelta}.\n *\n * @param {Object} options\n * @param {String} options.secret Shared secret key\n * @param {String} options.token Passcode to validate\n * @param {Integer} options.counter Counter value. This should be stored by\n *   the application and must be incremented for each request.\n * @param {Integer} [options.digits=6] The number of digits for the one-time\n *   passcode.\n * @param {Integer} [options.window=0] The allowable margin for the counter.\n *   The function will check \"W\" codes in the future against the provided\n *   passcode, e.g. if W = 10, and C = 5, this function will check the\n *   passcode against all One Time Passcodes between 5 and 15, inclusive.\n * @param {String} [options.encoding=\"ascii\"] Key encoding (ascii, hex,\n *   base32, base64).\n * @param {String} [options.algorithm=\"sha1\"] Hash algorithm (sha1, sha256,\n *   sha512).\n * @return {Boolean} Returns true if the token matches within the given\n *   window, false otherwise.\n * @method hotp․verify\n * @global\n */\n\n\nexports.hotp.verify = function hotpVerify(options) {\n  return exports.hotp.verifyDelta(options) != null;\n};\n/**\n * Calculate counter value based on given options. A counter value converts a\n * TOTP time into a counter value by finding the number of time steps that have\n * passed since the epoch to the current time.\n *\n * @param {Object} options\n * @param {Integer} [options.time] Time in seconds with which to calculate\n *   counter value. Defaults to `Date.now()`.\n * @param {Integer} [options.step=30] Time step in seconds\n * @param {Integer} [options.epoch=0] Initial time since the UNIX epoch from\n *   which to calculate the counter value. Defaults to 0 (no offset).\n * @param {Integer} [options.initial_time=0] (DEPRECATED. Use `epoch` instead.)\n *   Initial time in seconds since the UNIX epoch from which to calculate the\n *   counter value. Defaults to 0 (no offset).\n * @return {Integer} The calculated counter value.\n * @private\n */\n\n\nexports._counter = function _counter(options) {\n  var step = options.step || 30;\n  var time = options.time != null ? options.time * 1000 : Date.now(); // also accepts 'initial_time', but deprecated\n\n  var epoch = (options.epoch != null ? options.epoch * 1000 : options.initial_time * 1000) || 0;\n  if (options.initial_time != null) console.warn('Speakeasy - Deprecation Notice - Specifying the epoch using `initial_time` is no longer supported. Use `epoch` instead.');\n  return Math.floor((time - epoch) / step / 1000);\n};\n/**\n * Generate a time-based one-time token. Specify the key, and receive the\n * one-time password for that time as a string. By default, it uses the current\n * time and a time step of 30 seconds, so there is a new token every 30 seconds.\n * You may override the time step and epoch for custom timing. You can also\n * specify a token length, as well as the encoding (ASCII, hexadecimal, or\n * base32) and the hashing algorithm to use (SHA1, SHA256, SHA512).\n *\n * Under the hood, TOTP calculates the counter value by finding how many time\n * steps have passed since the epoch, and calls HOTP with that counter value.\n *\n * @param {Object} options\n * @param {String} options.secret Shared secret key\n * @param {Integer} [options.time] Time in seconds with which to calculate\n *   counter value. Defaults to `Date.now()`.\n * @param {Integer} [options.step=30] Time step in seconds\n * @param {Integer} [options.epoch=0] Initial time in seconds since the UNIX\n *   epoch from which to calculate the counter value. Defaults to 0 (no offset).\n * @param {Integer} [options.counter] Counter value, calculated by default.\n * @param {Integer} [options.digits=6] The number of digits for the one-time\n *   passcode.\n * @param {String} [options.encoding=\"ascii\"] Key encoding (ascii, hex,\n *   base32, base64).\n * @param {String} [options.algorithm=\"sha1\"] Hash algorithm (sha1, sha256,\n *   sha512).\n * @param {String} [options.key] (DEPRECATED. Use `secret` instead.)\n *   Shared secret key\n * @param {Integer} [options.initial_time=0] (DEPRECATED. Use `epoch` instead.)\n *   Initial time in seconds since the UNIX epoch from which to calculate the\n *   counter value. Defaults to 0 (no offset).\n * @param {Integer} [options.length=6] (DEPRECATED. Use `digits` instead.) The\n *   number of digits for the one-time passcode.\n * @return {String} The one-time passcode.\n */\n\n\nexports.totp = function totpGenerate(options) {\n  // shadow options\n  options = Object.create(options); // verify secret exists if key is not specified\n\n  var key = options.key;\n  var secret = options.secret;\n\n  if (key === null || typeof key === 'undefined') {\n    if (secret === null || typeof secret === 'undefined') {\n      throw new Error('Speakeasy - totp - Missing secret');\n    }\n  } // calculate default counter value\n\n\n  if (options.counter == null) options.counter = exports._counter(options); // pass to hotp\n\n  return this.hotp(options);\n}; // Alias time() for totp()\n\n\nexports.time = exports.totp;\n/**\n * Verify a time-based one-time token against the secret and return the delta.\n * By default, it verifies the token at the current time window, with no leeway\n * (no look-ahead or look-behind). A token validated at the current time window\n * will have a delta of 0.\n *\n * You can specify a window to add more leeway to the verification process.\n * Setting the window param will check for the token at the given counter value\n * as well as `window` tokens ahead and `window` tokens behind (two-sided\n * window). See param for more info.\n *\n * `verifyDelta()` will return the delta between the counter value of the token\n * and the given counter value. For example, if given a time at counter 1000 and\n * a window of 5, `verifyDelta()` will look at tokens from 995 to 1005,\n * inclusive. In other words, if the time-step is 30 seconds, it will look at\n * tokens from 2.5 minutes ago to 2.5 minutes in the future, inclusive.\n * If it finds it at counter position 1002, it will return `{ delta: 2 }`.\n * If it finds it at counter position 997, it will return `{ delta: -3 }`.\n *\n * @param {Object} options\n * @param {String} options.secret Shared secret key\n * @param {String} options.token Passcode to validate\n * @param {Integer} [options.time] Time in seconds with which to calculate\n *   counter value. Defaults to `Date.now()`.\n * @param {Integer} [options.step=30] Time step in seconds\n * @param {Integer} [options.epoch=0] Initial time in seconds since the UNIX\n *   epoch from which to calculate the counter value. Defaults to 0 (no offset).\n * @param {Integer} [options.counter] Counter value, calculated by default.\n * @param {Integer} [options.digits=6] The number of digits for the one-time\n *   passcode.\n * @param {Integer} [options.window=0] The allowable margin for the counter.\n *   The function will check \"W\" codes in the future and the past against the\n *   provided passcode, e.g. if W = 5, and C = 1000, this function will check\n *   the passcode against all One Time Passcodes between 995 and 1005,\n *   inclusive.\n * @param {String} [options.encoding=\"ascii\"] Key encoding (ascii, hex,\n *   base32, base64).\n * @param {String} [options.algorithm=\"sha1\"] Hash algorithm (sha1, sha256,\n *   sha512).\n * @return {Object} On success, returns an object with the time step\n *   difference between the client and the server as the `delta` property (e.g.\n *   `{ delta: 0 }`).\n * @method totp․verifyDelta\n * @global\n */\n\nexports.totp.verifyDelta = function totpVerifyDelta(options) {\n  // shadow options\n  options = Object.create(options); // verify secret and token exist\n\n  var secret = options.secret;\n  var token = options.token;\n  if (secret === null || typeof secret === 'undefined') throw new Error('Speakeasy - totp.verifyDelta - Missing secret');\n  if (token === null || typeof token === 'undefined') throw new Error('Speakeasy - totp.verifyDelta - Missing token'); // unpack options\n\n  var window = parseInt(options.window, 10) || 0; // calculate default counter value\n\n  if (options.counter == null) options.counter = exports._counter(options); // adjust for two-sided window\n\n  options.counter -= window;\n  options.window += window; // pass to hotp.verifyDelta\n\n  var delta = exports.hotp.verifyDelta(options); // adjust for two-sided window\n\n  if (delta) {\n    delta.delta -= window;\n  }\n\n  return delta;\n};\n/**\n * Verify a time-based one-time token against the secret and return true if it\n * verifies. Helper function for verifyDelta() that returns a boolean instead of\n * an object. For more on how to use a window with this, see\n * {@link totp.verifyDelta}.\n *\n * @param {Object} options\n * @param {String} options.secret Shared secret key\n * @param {String} options.token Passcode to validate\n * @param {Integer} [options.time] Time in seconds with which to calculate\n *   counter value. Defaults to `Date.now()`.\n * @param {Integer} [options.step=30] Time step in seconds\n * @param {Integer} [options.epoch=0] Initial time in seconds  since the UNIX\n *   epoch from which to calculate the counter value. Defaults to 0 (no offset).\n * @param {Integer} [options.counter] Counter value, calculated by default.\n * @param {Integer} [options.digits=6] The number of digits for the one-time\n *   passcode.\n * @param {Integer} [options.window=0] The allowable margin for the counter.\n *   The function will check \"W\" codes in the future and the past against the\n *   provided passcode, e.g. if W = 5, and C = 1000, this function will check\n *   the passcode against all One Time Passcodes between 995 and 1005,\n *   inclusive.\n * @param {String} [options.encoding=\"ascii\"] Key encoding (ascii, hex,\n *   base32, base64).\n * @param {String} [options.algorithm=\"sha1\"] Hash algorithm (sha1, sha256,\n *   sha512).\n * @return {Boolean} Returns true if the token matches within the given\n *   window, false otherwise.\n * @method totp․verify\n * @global\n */\n\n\nexports.totp.verify = function totpVerify(options) {\n  return exports.totp.verifyDelta(options) != null;\n};\n/**\n * @typedef GeneratedSecret\n * @type Object\n * @property {String} ascii ASCII representation of the secret\n * @property {String} hex Hex representation of the secret\n * @property {String} base32 Base32 representation of the secret\n * @property {String} qr_code_ascii URL for the QR code for the ASCII secret.\n * @property {String} qr_code_hex URL for the QR code for the hex secret.\n * @property {String} qr_code_base32 URL for the QR code for the base32 secret.\n * @property {String} google_auth_qr URL for the Google Authenticator otpauth\n *   URL's QR code.\n * @property {String} otpauth_url Google Authenticator-compatible otpauth URL.\n */\n\n/**\n * Generates a random secret with the set A-Z a-z 0-9 and symbols, of any length\n * (default 32). Returns the secret key in ASCII, hexadecimal, and base32 format,\n * along with the URL used for the QR code for Google Authenticator (an otpauth\n * URL). Use a QR code library to generate a QR code based on the Google\n * Authenticator URL to obtain a QR code you can scan into the app.\n *\n * @param {Object} options\n * @param {Integer} [options.length=32] Length of the secret\n * @param {Boolean} [options.symbols=false] Whether to include symbols\n * @param {Boolean} [options.otpauth_url=true] Whether to output a Google\n *   Authenticator-compatible otpauth:// URL (only returns otpauth:// URL, no\n *   QR code)\n * @param {String} [options.name] The name to use with Google Authenticator.\n * @param {Boolean} [options.qr_codes=false] (DEPRECATED. Do not use to prevent\n *   leaking of secret to a third party. Use your own QR code implementation.)\n *   Output QR code URLs for the token.\n * @param {Boolean} [options.google_auth_qr=false] (DEPRECATED. Do not use to\n *   prevent leaking of secret to a third party. Use your own QR code\n *   implementation.) Output a Google Authenticator otpauth:// QR code URL.\n * @param {String} [options.issuer=''] The provider or service with which the\n *   secret key is associated.\n * @return {Object}\n * @return {GeneratedSecret} The generated secret key.\n */\n\n\nexports.generateSecret = function generateSecret(options) {\n  // options\n  if (!options) options = {};\n  var length = options.length || 32;\n  var name = options.name || 'SecretKey';\n  var qr_codes = options.qr_codes || false;\n  var google_auth_qr = options.google_auth_qr || false;\n  var otpauth_url = options.otpauth_url != null ? options.otpauth_url : true;\n  var symbols = true;\n  var issuer = options.issuer; // turn off symbols only when explicity told to\n\n  if (options.symbols !== undefined && options.symbols === false) {\n    symbols = false;\n  } // generate an ascii key\n\n\n  var key = this.generateSecretASCII(length, symbols); // return a SecretKey with ascii, hex, and base32\n\n  var SecretKey = {};\n  SecretKey.ascii = key;\n  SecretKey.hex = Buffer(key, 'ascii').toString('hex');\n  SecretKey.base32 = base32.encode(Buffer(key)).toString().replace(/=/g, ''); // generate some qr codes if requested\n\n  if (qr_codes) {\n    console.warn('Speakeasy - Deprecation Notice - generateSecret() QR codes are deprecated and no longer supported. Please use your own QR code implementation.');\n    SecretKey.qr_code_ascii = 'https://chart.googleapis.com/chart?chs=166x166&chld=L|0&cht=qr&chl=' + encodeURIComponent(SecretKey.ascii);\n    SecretKey.qr_code_hex = 'https://chart.googleapis.com/chart?chs=166x166&chld=L|0&cht=qr&chl=' + encodeURIComponent(SecretKey.hex);\n    SecretKey.qr_code_base32 = 'https://chart.googleapis.com/chart?chs=166x166&chld=L|0&cht=qr&chl=' + encodeURIComponent(SecretKey.base32);\n  } // add in the Google Authenticator-compatible otpauth URL\n\n\n  if (otpauth_url) {\n    SecretKey.otpauth_url = exports.otpauthURL({\n      secret: SecretKey.ascii,\n      label: name,\n      issuer: issuer\n    });\n  } // generate a QR code for use in Google Authenticator if requested\n\n\n  if (google_auth_qr) {\n    console.warn('Speakeasy - Deprecation Notice - generateSecret() Google Auth QR code is deprecated and no longer supported. Please use your own QR code implementation.');\n    SecretKey.google_auth_qr = 'https://chart.googleapis.com/chart?chs=166x166&chld=L|0&cht=qr&chl=' + encodeURIComponent(exports.otpauthURL({\n      secret: SecretKey.base32,\n      label: name\n    }));\n  }\n\n  return SecretKey;\n}; // Backwards compatibility - generate_key is deprecated\n\n\nexports.generate_key = util.deprecate(function (options) {\n  return exports.generateSecret(options);\n}, 'Speakeasy - Deprecation Notice - `generate_key()` is depreciated, please use `generateSecret()` instead.');\n/**\n * Generates a key of a certain length (default 32) from A-Z, a-z, 0-9, and\n * symbols (if requested).\n *\n * @param  {Integer} [length=32]  The length of the key.\n * @param  {Boolean} [symbols=false] Whether to include symbols in the key.\n * @return {String} The generated key.\n */\n\nexports.generateSecretASCII = function generateSecretASCII(length, symbols) {\n  var bytes = crypto.randomBytes(length || 32);\n  var set = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz';\n\n  if (symbols) {\n    set += '!@#$%^&*()<>?/[]{},.:;';\n  }\n\n  var output = '';\n\n  for (var i = 0, l = bytes.length; i < l; i++) {\n    output += set[Math.floor(bytes[i] / 255.0 * (set.length - 1))];\n  }\n\n  return output;\n}; // Backwards compatibility - generate_key_ascii is deprecated\n\n\nexports.generate_key_ascii = util.deprecate(function (length, symbols) {\n  return exports.generateSecretASCII(length, symbols);\n}, 'Speakeasy - Deprecation Notice - `generate_key_ascii()` is depreciated, please use `generateSecretASCII()` instead.');\n/**\n * Generate a Google Authenticator-compatible otpauth:// URL for passing the\n * secret to a mobile device to install the secret.\n *\n * Authenticator considers TOTP codes valid for 30 seconds. Additionally,\n * the app presents 6 digits codes to the user. According to the\n * documentation, the period and number of digits are currently ignored by\n * the app.\n *\n * To generate a suitable QR Code, pass the generated URL to a QR Code\n * generator, such as the `qr-image` module.\n *\n * @param {Object} options\n * @param {String} options.secret Shared secret key\n * @param {String} options.label Used to identify the account with which\n *   the secret key is associated, e.g. the user's email address.\n * @param {String} [options.type=\"totp\"] Either \"hotp\" or \"totp\".\n * @param {Integer} [options.counter] The initial counter value, required\n *   for HOTP.\n * @param {String} [options.issuer] The provider or service with which the\n *   secret key is associated.\n * @param {String} [options.algorithm=\"sha1\"] Hash algorithm (sha1, sha256,\n *   sha512).\n * @param {Integer} [options.digits=6] The number of digits for the one-time\n *   passcode. Currently ignored by Google Authenticator.\n * @param {Integer} [options.period=30] The length of time for which a TOTP\n *   code will be valid, in seconds. Currently ignored by Google\n *   Authenticator.\n * @param {String} [options.encoding] Key encoding (ascii, hex, base32,\n *   base64). If the key is not encoded in Base-32, it will be reencoded.\n * @return {String} A URL suitable for use with the Google Authenticator.\n * @throws Error if secret or label is missing, or if hotp is used and a\n    counter is missing, if the type is not one of `hotp` or `totp`, if the\n    number of digits is non-numeric, or an invalid period is used. Warns if\n    the number of digits is not either 6 or 8 (though 6 is the only one\n    supported by Google Authenticator), and if the hashihng algorithm is\n    not one of the supported SHA1, SHA256, or SHA512.\n * @see https://github.com/google/google-authenticator/wiki/Key-Uri-Format\n */\n\nexports.otpauthURL = function otpauthURL(options) {\n  // unpack options\n  var secret = options.secret;\n  var label = options.label;\n  var issuer = options.issuer;\n  var type = (options.type || 'totp').toLowerCase();\n  var counter = options.counter;\n  var algorithm = (options.algorithm || 'sha1').toLowerCase();\n  var digits = options.digits || 6;\n  var period = options.period || 30;\n  var encoding = options.encoding || 'ascii'; // validate type\n\n  switch (type) {\n    case 'totp':\n    case 'hotp':\n      break;\n\n    default:\n      throw new Error('Speakeasy - otpauthURL - Invalid type `' + type + '`; must be `hotp` or `totp`');\n  } // validate required options\n\n\n  if (!secret) throw new Error('Speakeasy - otpauthURL - Missing secret');\n  if (!label) throw new Error('Speakeasy - otpauthURL - Missing label'); // require counter for HOTP\n\n  if (type === 'hotp' && (counter === null || typeof counter === 'undefined')) {\n    throw new Error('Speakeasy - otpauthURL - Missing counter value for HOTP');\n  } // convert secret to base32\n\n\n  if (encoding !== 'base32') secret = new Buffer(secret, encoding);\n  if (Buffer.isBuffer(secret)) secret = base32.encode(secret); // build query while validating\n\n  var query = {\n    secret: secret\n  };\n  if (issuer) query.issuer = issuer;\n\n  if (type === 'hotp') {\n    query.counter = counter;\n  } // validate algorithm\n\n\n  if (algorithm != null) {\n    switch (algorithm.toUpperCase()) {\n      case 'SHA1':\n      case 'SHA256':\n      case 'SHA512':\n        break;\n\n      default:\n        console.warn('Speakeasy - otpauthURL - Warning - Algorithm generally should be SHA1, SHA256, or SHA512');\n    }\n\n    query.algorithm = algorithm.toUpperCase();\n  } // validate digits\n\n\n  if (digits != null) {\n    if (isNaN(digits)) {\n      throw new Error('Speakeasy - otpauthURL - Invalid digits `' + digits + '`');\n    } else {\n      switch (parseInt(digits, 10)) {\n        case 6:\n        case 8:\n          break;\n\n        default:\n          console.warn('Speakeasy - otpauthURL - Warning - Digits generally should be either 6 or 8');\n      }\n    }\n\n    query.digits = digits;\n  } // validate period\n\n\n  if (period != null) {\n    period = parseInt(period, 10);\n\n    if (~~period !== period) {\n      throw new Error('Speakeasy - otpauthURL - Invalid period `' + period + '`');\n    }\n\n    query.period = period;\n  } // return url\n\n\n  return url.format({\n    protocol: 'otpauth',\n    slashes: true,\n    hostname: type,\n    pathname: encodeURIComponent(label),\n    query: query\n  });\n};","map":{"version":3,"names":["base32","require","crypto","url","util","exports","digest","options","i","secret","counter","encoding","algorithm","toLowerCase","key","console","warn","Buffer","isBuffer","decode","secret_buffer_size","length","Array","Math","ceil","join","toString","slice","buf","tmp","hmac","createHmac","update","hotp","hotpGenerate","Error","digits","offset","code","substr","verifyDelta","hotpVerifyDelta","Object","create","token","String","parseInt","window","isNaN","delta","verify","hotpVerify","_counter","step","time","Date","now","epoch","initial_time","floor","totp","totpGenerate","totpVerifyDelta","totpVerify","generateSecret","name","qr_codes","google_auth_qr","otpauth_url","symbols","issuer","undefined","generateSecretASCII","SecretKey","ascii","hex","encode","replace","qr_code_ascii","encodeURIComponent","qr_code_hex","qr_code_base32","otpauthURL","label","generate_key","deprecate","bytes","randomBytes","set","output","l","generate_key_ascii","type","period","query","toUpperCase","format","protocol","slashes","hostname","pathname"],"sources":["/Users/nileshpanhale/Documents/Test_Frontend/node_modules/speakeasy-latest/index.js"],"sourcesContent":["'use strict';\n\nvar base32 = require('base32.js');\nvar crypto = require('crypto');\nvar url = require('url');\nvar util = require('util');\n\n/**\n * Digest the one-time passcode options.\n *\n * @param {Object} options\n * @param {String} options.secret Shared secret key\n * @param {Integer} options.counter Counter value\n * @param {String} [options.encoding=\"ascii\"] Key encoding (ascii, hex,\n *   base32, base64).\n * @param {String} [options.algorithm=\"sha1\"] Hash algorithm (sha1, sha256,\n *   sha512).\n * @param {String} [options.key] (DEPRECATED. Use `secret` instead.)\n *   Shared secret key\n * @return {Buffer} The one-time passcode as a buffer.\n */\n\nexports.digest = function digest (options) {\n  var i;\n\n  // unpack options\n  var secret = options.secret;\n  var counter = options.counter;\n  var encoding = options.encoding || 'ascii';\n  var algorithm = (options.algorithm || 'sha1').toLowerCase();\n\n  // Backwards compatibility - deprecated\n  if (options.key != null) {\n    console.warn('Speakeasy - Deprecation Notice - Specifying the secret using `key` is no longer supported. Use `secret` instead.');\n    secret = options.key;\n  }\n\n  // convert secret to buffer\n  if (!Buffer.isBuffer(secret)) {\n    if (encoding === 'base32') { secret = base32.decode(secret); }\n    secret = new Buffer(secret, encoding);\n  }\n\n  var secret_buffer_size;\n  if (algorithm === 'sha1') {\n    secret_buffer_size = 20; // 20 bytes\n  } else if (algorithm === 'sha256') {\n    secret_buffer_size = 32; // 32 bytes\n  } else if (algorithm === 'sha512') {\n    secret_buffer_size = 64; // 64 bytes\n  } else {\n    console.warn('Speakeasy - The algorithm provided (`' + algorithm + '`) is not officially supported, results may be different than expected.');\n  }\n\n  // The secret for sha1, sha256 and sha512 needs to be a fixed number of bytes for the one-time-password to be calculated correctly\n  // Pad the buffer to the correct size be repeating the secret to the desired length\n  if (secret_buffer_size && secret.length !== secret_buffer_size) {\n    secret = new Buffer(Array(Math.ceil(secret_buffer_size / secret.length) + 1).join(secret.toString('hex')), 'hex').slice(0, secret_buffer_size);\n  }\n\n  // create an buffer from the counter\n  var buf = new Buffer(8);\n  var tmp = counter;\n  for (i = 0; i < 8; i++) {\n    // mask 0xff over number to get last 8\n    buf[7 - i] = tmp & 0xff;\n\n    // shift 8 and get ready to loop over the next batch of 8\n    tmp = tmp >> 8;\n  }\n\n  // init hmac with the key\n  var hmac = crypto.createHmac(algorithm, secret);\n\n  // update hmac with the counter\n  hmac.update(buf);\n\n  // return the digest\n  return hmac.digest();\n};\n\n/**\n * Generate a counter-based one-time token. Specify the key and counter, and\n * receive the one-time password for that counter position as a string. You can\n * also specify a token length, as well as the encoding (ASCII, hexadecimal, or\n * base32) and the hashing algorithm to use (SHA1, SHA256, SHA512).\n *\n * @param {Object} options\n * @param {String} options.secret Shared secret key\n * @param {Integer} options.counter Counter value\n * @param {Buffer} [options.digest] Digest, automatically generated by default\n * @param {Integer} [options.digits=6] The number of digits for the one-time\n *   passcode.\n * @param {String} [options.encoding=\"ascii\"] Key encoding (ascii, hex,\n *   base32, base64).\n * @param {String} [options.algorithm=\"sha1\"] Hash algorithm (sha1, sha256,\n *   sha512).\n * @param {String} [options.key] (DEPRECATED. Use `secret` instead.)\n *   Shared secret key\n * @param {Integer} [options.length=6] (DEPRECATED. Use `digits` instead.) The\n *   number of digits for the one-time passcode.\n * @return {String} The one-time passcode.\n */\n\nexports.hotp = function hotpGenerate (options) {\n\n  // verify secret and counter exists\n  var secret = options.secret;\n  var key = options.key;\n  var counter = options.counter;\n\n  if (key === null || typeof key === 'undefined') {\n    if (secret === null || typeof secret === 'undefined') {\n      throw new Error('Speakeasy - hotp - Missing secret');\n    }\n  }\n\n  if (counter === null || typeof counter === 'undefined') {\n    throw new Error('Speakeasy - hotp - Missing counter');\n  }\n\n  // unpack digits\n  // backward compatibility: `length` is also accepted here, but deprecated\n  var digits = (options.digits != null ? options.digits : options.length) || 6;\n  if (options.length != null) console.warn('Speakeasy - Deprecation Notice - Specifying token digits using `length` is no longer supported. Use `digits` instead.');\n\n  // digest the options\n  var digest = options.digest || exports.digest(options);\n\n  // compute HOTP offset\n  var offset = digest[digest.length - 1] & 0xf;\n\n  // calculate binary code (RFC4226 5.4)\n  var code = (digest[offset] & 0x7f) << 24 |\n    (digest[offset + 1] & 0xff) << 16 |\n    (digest[offset + 2] & 0xff) << 8 |\n    (digest[offset + 3] & 0xff);\n\n  // left-pad code\n  code = new Array(digits + 1).join('0') + code.toString(10);\n\n  // return length number off digits\n  return code.substr(-digits);\n};\n\n// Alias counter() for hotp()\nexports.counter = exports.hotp;\n\n/**\n * Verify a counter-based one-time token against the secret and return the delta.\n * By default, it verifies the token at the given counter value, with no leeway\n * (no look-ahead or look-behind). A token validated at the current counter value\n * will have a delta of 0.\n *\n * You can specify a window to add more leeway to the verification process.\n * Setting the window param will check for the token at the given counter value\n * as well as `window` tokens ahead (one-sided window). See param for more info.\n *\n * `verifyDelta()` will return the delta between the counter value of the token\n * and the given counter value. For example, if given a counter 5 and a window\n * 10, `verifyDelta()` will look at tokens from 5 to 15, inclusive. If it finds\n * it at counter position 7, it will return `{ delta: 2 }`.\n *\n * @param {Object} options\n * @param {String} options.secret Shared secret key\n * @param {String} options.token Passcode to validate\n * @param {Integer} options.counter Counter value. This should be stored by\n *   the application and must be incremented for each request.\n * @param {Integer} [options.digits=6] The number of digits for the one-time\n *   passcode.\n * @param {Integer} [options.window=0] The allowable margin for the counter.\n *   The function will check \"W\" codes in the future against the provided\n *   passcode, e.g. if W = 10, and C = 5, this function will check the\n *   passcode against all One Time Passcodes between 5 and 15, inclusive.\n * @param {String} [options.encoding=\"ascii\"] Key encoding (ascii, hex,\n *   base32, base64).\n * @param {String} [options.algorithm=\"sha1\"] Hash algorithm (sha1, sha256,\n *   sha512).\n * @return {Object} On success, returns an object with the counter\n *   difference between the client and the server as the `delta` property (i.e.\n *   `{ delta: 0 }`).\n * @method hotp․verifyDelta\n * @global\n */\n\nexports.hotp.verifyDelta = function hotpVerifyDelta (options) {\n  var i;\n\n  // shadow options\n  options = Object.create(options);\n\n  // verify secret and token exist\n  var secret = options.secret;\n  var token = options.token;\n  if (secret === null || typeof secret === 'undefined') throw new Error('Speakeasy - hotp.verifyDelta - Missing secret');\n  if (token === null || typeof token === 'undefined') throw new Error('Speakeasy - hotp.verifyDelta - Missing token');\n\n  // unpack options\n  var token = String(options.token);\n  var digits = parseInt(options.digits, 10) || 6;\n  var window = parseInt(options.window, 10) || 0;\n  var counter = parseInt(options.counter, 10) || 0;\n\n  // fail if token is not of correct length\n  if (token.length !== digits) {\n    return;\n  }\n\n  // parse token to integer\n  token = parseInt(token, 10);\n\n  // fail if token is NA\n  if (isNaN(token)) {\n    return;\n  }\n\n  // loop from C to C + W inclusive\n  for (i = counter; i <= counter + window; ++i) {\n    options.counter = i;\n    // domain-specific constant-time comparison for integer codes\n    if (parseInt(exports.hotp(options), 10) === token) {\n      // found a matching code, return delta\n      return {delta: i - counter};\n    }\n  }\n\n  // no codes have matched\n};\n\n/**\n * Verify a counter-based one-time token against the secret and return true if\n * it verifies. Helper function for `hotp.verifyDelta()`` that returns a boolean\n * instead of an object. For more on how to use a window with this, see\n * {@link hotp.verifyDelta}.\n *\n * @param {Object} options\n * @param {String} options.secret Shared secret key\n * @param {String} options.token Passcode to validate\n * @param {Integer} options.counter Counter value. This should be stored by\n *   the application and must be incremented for each request.\n * @param {Integer} [options.digits=6] The number of digits for the one-time\n *   passcode.\n * @param {Integer} [options.window=0] The allowable margin for the counter.\n *   The function will check \"W\" codes in the future against the provided\n *   passcode, e.g. if W = 10, and C = 5, this function will check the\n *   passcode against all One Time Passcodes between 5 and 15, inclusive.\n * @param {String} [options.encoding=\"ascii\"] Key encoding (ascii, hex,\n *   base32, base64).\n * @param {String} [options.algorithm=\"sha1\"] Hash algorithm (sha1, sha256,\n *   sha512).\n * @return {Boolean} Returns true if the token matches within the given\n *   window, false otherwise.\n * @method hotp․verify\n * @global\n */\nexports.hotp.verify = function hotpVerify (options) {\n  return exports.hotp.verifyDelta(options) != null;\n};\n\n/**\n * Calculate counter value based on given options. A counter value converts a\n * TOTP time into a counter value by finding the number of time steps that have\n * passed since the epoch to the current time.\n *\n * @param {Object} options\n * @param {Integer} [options.time] Time in seconds with which to calculate\n *   counter value. Defaults to `Date.now()`.\n * @param {Integer} [options.step=30] Time step in seconds\n * @param {Integer} [options.epoch=0] Initial time since the UNIX epoch from\n *   which to calculate the counter value. Defaults to 0 (no offset).\n * @param {Integer} [options.initial_time=0] (DEPRECATED. Use `epoch` instead.)\n *   Initial time in seconds since the UNIX epoch from which to calculate the\n *   counter value. Defaults to 0 (no offset).\n * @return {Integer} The calculated counter value.\n * @private\n */\n\nexports._counter = function _counter (options) {\n  var step = options.step || 30;\n  var time = options.time != null ? (options.time * 1000) : Date.now();\n\n  // also accepts 'initial_time', but deprecated\n  var epoch = (options.epoch != null ? (options.epoch * 1000) : (options.initial_time * 1000)) || 0;\n  if (options.initial_time != null) console.warn('Speakeasy - Deprecation Notice - Specifying the epoch using `initial_time` is no longer supported. Use `epoch` instead.');\n\n  return Math.floor((time - epoch) / step / 1000);\n};\n\n/**\n * Generate a time-based one-time token. Specify the key, and receive the\n * one-time password for that time as a string. By default, it uses the current\n * time and a time step of 30 seconds, so there is a new token every 30 seconds.\n * You may override the time step and epoch for custom timing. You can also\n * specify a token length, as well as the encoding (ASCII, hexadecimal, or\n * base32) and the hashing algorithm to use (SHA1, SHA256, SHA512).\n *\n * Under the hood, TOTP calculates the counter value by finding how many time\n * steps have passed since the epoch, and calls HOTP with that counter value.\n *\n * @param {Object} options\n * @param {String} options.secret Shared secret key\n * @param {Integer} [options.time] Time in seconds with which to calculate\n *   counter value. Defaults to `Date.now()`.\n * @param {Integer} [options.step=30] Time step in seconds\n * @param {Integer} [options.epoch=0] Initial time in seconds since the UNIX\n *   epoch from which to calculate the counter value. Defaults to 0 (no offset).\n * @param {Integer} [options.counter] Counter value, calculated by default.\n * @param {Integer} [options.digits=6] The number of digits for the one-time\n *   passcode.\n * @param {String} [options.encoding=\"ascii\"] Key encoding (ascii, hex,\n *   base32, base64).\n * @param {String} [options.algorithm=\"sha1\"] Hash algorithm (sha1, sha256,\n *   sha512).\n * @param {String} [options.key] (DEPRECATED. Use `secret` instead.)\n *   Shared secret key\n * @param {Integer} [options.initial_time=0] (DEPRECATED. Use `epoch` instead.)\n *   Initial time in seconds since the UNIX epoch from which to calculate the\n *   counter value. Defaults to 0 (no offset).\n * @param {Integer} [options.length=6] (DEPRECATED. Use `digits` instead.) The\n *   number of digits for the one-time passcode.\n * @return {String} The one-time passcode.\n */\n\nexports.totp = function totpGenerate (options) {\n  // shadow options\n  options = Object.create(options);\n\n  // verify secret exists if key is not specified\n  var key = options.key;\n  var secret = options.secret;\n  if (key === null || typeof key === 'undefined') {\n    if (secret === null || typeof secret === 'undefined') {\n      throw new Error('Speakeasy - totp - Missing secret');\n    }\n  }\n\n  // calculate default counter value\n  if (options.counter == null) options.counter = exports._counter(options);\n\n  // pass to hotp\n  return this.hotp(options);\n};\n\n// Alias time() for totp()\nexports.time = exports.totp;\n\n/**\n * Verify a time-based one-time token against the secret and return the delta.\n * By default, it verifies the token at the current time window, with no leeway\n * (no look-ahead or look-behind). A token validated at the current time window\n * will have a delta of 0.\n *\n * You can specify a window to add more leeway to the verification process.\n * Setting the window param will check for the token at the given counter value\n * as well as `window` tokens ahead and `window` tokens behind (two-sided\n * window). See param for more info.\n *\n * `verifyDelta()` will return the delta between the counter value of the token\n * and the given counter value. For example, if given a time at counter 1000 and\n * a window of 5, `verifyDelta()` will look at tokens from 995 to 1005,\n * inclusive. In other words, if the time-step is 30 seconds, it will look at\n * tokens from 2.5 minutes ago to 2.5 minutes in the future, inclusive.\n * If it finds it at counter position 1002, it will return `{ delta: 2 }`.\n * If it finds it at counter position 997, it will return `{ delta: -3 }`.\n *\n * @param {Object} options\n * @param {String} options.secret Shared secret key\n * @param {String} options.token Passcode to validate\n * @param {Integer} [options.time] Time in seconds with which to calculate\n *   counter value. Defaults to `Date.now()`.\n * @param {Integer} [options.step=30] Time step in seconds\n * @param {Integer} [options.epoch=0] Initial time in seconds since the UNIX\n *   epoch from which to calculate the counter value. Defaults to 0 (no offset).\n * @param {Integer} [options.counter] Counter value, calculated by default.\n * @param {Integer} [options.digits=6] The number of digits for the one-time\n *   passcode.\n * @param {Integer} [options.window=0] The allowable margin for the counter.\n *   The function will check \"W\" codes in the future and the past against the\n *   provided passcode, e.g. if W = 5, and C = 1000, this function will check\n *   the passcode against all One Time Passcodes between 995 and 1005,\n *   inclusive.\n * @param {String} [options.encoding=\"ascii\"] Key encoding (ascii, hex,\n *   base32, base64).\n * @param {String} [options.algorithm=\"sha1\"] Hash algorithm (sha1, sha256,\n *   sha512).\n * @return {Object} On success, returns an object with the time step\n *   difference between the client and the server as the `delta` property (e.g.\n *   `{ delta: 0 }`).\n * @method totp․verifyDelta\n * @global\n */\n\nexports.totp.verifyDelta = function totpVerifyDelta (options) {\n  // shadow options\n  options = Object.create(options);\n  // verify secret and token exist\n  var secret = options.secret;\n  var token = options.token;\n  if (secret === null || typeof secret === 'undefined') throw new Error('Speakeasy - totp.verifyDelta - Missing secret');\n  if (token === null || typeof token === 'undefined') throw new Error('Speakeasy - totp.verifyDelta - Missing token');\n\n  // unpack options\n  var window = parseInt(options.window, 10) || 0;\n\n  // calculate default counter value\n  if (options.counter == null) options.counter = exports._counter(options);\n\n  // adjust for two-sided window\n  options.counter -= window;\n  options.window += window;\n\n  // pass to hotp.verifyDelta\n  var delta = exports.hotp.verifyDelta(options);\n\n  // adjust for two-sided window\n  if (delta) {\n    delta.delta -= window;\n  }\n\n  return delta;\n};\n\n/**\n * Verify a time-based one-time token against the secret and return true if it\n * verifies. Helper function for verifyDelta() that returns a boolean instead of\n * an object. For more on how to use a window with this, see\n * {@link totp.verifyDelta}.\n *\n * @param {Object} options\n * @param {String} options.secret Shared secret key\n * @param {String} options.token Passcode to validate\n * @param {Integer} [options.time] Time in seconds with which to calculate\n *   counter value. Defaults to `Date.now()`.\n * @param {Integer} [options.step=30] Time step in seconds\n * @param {Integer} [options.epoch=0] Initial time in seconds  since the UNIX\n *   epoch from which to calculate the counter value. Defaults to 0 (no offset).\n * @param {Integer} [options.counter] Counter value, calculated by default.\n * @param {Integer} [options.digits=6] The number of digits for the one-time\n *   passcode.\n * @param {Integer} [options.window=0] The allowable margin for the counter.\n *   The function will check \"W\" codes in the future and the past against the\n *   provided passcode, e.g. if W = 5, and C = 1000, this function will check\n *   the passcode against all One Time Passcodes between 995 and 1005,\n *   inclusive.\n * @param {String} [options.encoding=\"ascii\"] Key encoding (ascii, hex,\n *   base32, base64).\n * @param {String} [options.algorithm=\"sha1\"] Hash algorithm (sha1, sha256,\n *   sha512).\n * @return {Boolean} Returns true if the token matches within the given\n *   window, false otherwise.\n * @method totp․verify\n * @global\n */\nexports.totp.verify = function totpVerify (options) {\n  return exports.totp.verifyDelta(options) != null;\n};\n\n/**\n * @typedef GeneratedSecret\n * @type Object\n * @property {String} ascii ASCII representation of the secret\n * @property {String} hex Hex representation of the secret\n * @property {String} base32 Base32 representation of the secret\n * @property {String} qr_code_ascii URL for the QR code for the ASCII secret.\n * @property {String} qr_code_hex URL for the QR code for the hex secret.\n * @property {String} qr_code_base32 URL for the QR code for the base32 secret.\n * @property {String} google_auth_qr URL for the Google Authenticator otpauth\n *   URL's QR code.\n * @property {String} otpauth_url Google Authenticator-compatible otpauth URL.\n */\n\n/**\n * Generates a random secret with the set A-Z a-z 0-9 and symbols, of any length\n * (default 32). Returns the secret key in ASCII, hexadecimal, and base32 format,\n * along with the URL used for the QR code for Google Authenticator (an otpauth\n * URL). Use a QR code library to generate a QR code based on the Google\n * Authenticator URL to obtain a QR code you can scan into the app.\n *\n * @param {Object} options\n * @param {Integer} [options.length=32] Length of the secret\n * @param {Boolean} [options.symbols=false] Whether to include symbols\n * @param {Boolean} [options.otpauth_url=true] Whether to output a Google\n *   Authenticator-compatible otpauth:// URL (only returns otpauth:// URL, no\n *   QR code)\n * @param {String} [options.name] The name to use with Google Authenticator.\n * @param {Boolean} [options.qr_codes=false] (DEPRECATED. Do not use to prevent\n *   leaking of secret to a third party. Use your own QR code implementation.)\n *   Output QR code URLs for the token.\n * @param {Boolean} [options.google_auth_qr=false] (DEPRECATED. Do not use to\n *   prevent leaking of secret to a third party. Use your own QR code\n *   implementation.) Output a Google Authenticator otpauth:// QR code URL.\n * @param {String} [options.issuer=''] The provider or service with which the\n *   secret key is associated.\n * @return {Object}\n * @return {GeneratedSecret} The generated secret key.\n */\nexports.generateSecret = function generateSecret (options) {\n  // options\n  if (!options) options = {};\n  var length = options.length || 32;\n  var name = options.name || 'SecretKey';\n  var qr_codes = options.qr_codes || false;\n  var google_auth_qr = options.google_auth_qr || false;\n  var otpauth_url = options.otpauth_url != null ? options.otpauth_url : true;\n  var symbols = true;\n  var issuer = options.issuer;\n\n  // turn off symbols only when explicity told to\n  if (options.symbols !== undefined && options.symbols === false) {\n    symbols = false;\n  }\n\n  // generate an ascii key\n  var key = this.generateSecretASCII(length, symbols);\n\n  // return a SecretKey with ascii, hex, and base32\n  var SecretKey = {};\n  SecretKey.ascii = key;\n  SecretKey.hex = Buffer(key, 'ascii').toString('hex');\n  SecretKey.base32 = base32.encode(Buffer(key)).toString().replace(/=/g, '');\n\n  // generate some qr codes if requested\n  if (qr_codes) {\n    console.warn('Speakeasy - Deprecation Notice - generateSecret() QR codes are deprecated and no longer supported. Please use your own QR code implementation.');\n    SecretKey.qr_code_ascii = 'https://chart.googleapis.com/chart?chs=166x166&chld=L|0&cht=qr&chl=' + encodeURIComponent(SecretKey.ascii);\n    SecretKey.qr_code_hex = 'https://chart.googleapis.com/chart?chs=166x166&chld=L|0&cht=qr&chl=' + encodeURIComponent(SecretKey.hex);\n    SecretKey.qr_code_base32 = 'https://chart.googleapis.com/chart?chs=166x166&chld=L|0&cht=qr&chl=' + encodeURIComponent(SecretKey.base32);\n  }\n\n  // add in the Google Authenticator-compatible otpauth URL\n  if (otpauth_url) {\n    SecretKey.otpauth_url = exports.otpauthURL({\n      secret: SecretKey.ascii,\n      label: name,\n      issuer: issuer\n    });\n  }\n\n  // generate a QR code for use in Google Authenticator if requested\n  if (google_auth_qr) {\n    console.warn('Speakeasy - Deprecation Notice - generateSecret() Google Auth QR code is deprecated and no longer supported. Please use your own QR code implementation.');\n    SecretKey.google_auth_qr = 'https://chart.googleapis.com/chart?chs=166x166&chld=L|0&cht=qr&chl=' + encodeURIComponent(exports.otpauthURL({ secret: SecretKey.base32, label: name }));\n  }\n\n  return SecretKey;\n};\n\n// Backwards compatibility - generate_key is deprecated\nexports.generate_key = util.deprecate(function (options) {\n  return exports.generateSecret(options);\n}, 'Speakeasy - Deprecation Notice - `generate_key()` is depreciated, please use `generateSecret()` instead.');\n\n/**\n * Generates a key of a certain length (default 32) from A-Z, a-z, 0-9, and\n * symbols (if requested).\n *\n * @param  {Integer} [length=32]  The length of the key.\n * @param  {Boolean} [symbols=false] Whether to include symbols in the key.\n * @return {String} The generated key.\n */\nexports.generateSecretASCII = function generateSecretASCII (length, symbols) {\n  var bytes = crypto.randomBytes(length || 32);\n  var set = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz';\n  if (symbols) {\n    set += '!@#$%^&*()<>?/[]{},.:;';\n  }\n\n  var output = '';\n  for (var i = 0, l = bytes.length; i < l; i++) {\n    output += set[Math.floor(bytes[i] / 255.0 * (set.length - 1))];\n  }\n  return output;\n};\n\n// Backwards compatibility - generate_key_ascii is deprecated\nexports.generate_key_ascii = util.deprecate(function (length, symbols) {\n  return exports.generateSecretASCII(length, symbols);\n}, 'Speakeasy - Deprecation Notice - `generate_key_ascii()` is depreciated, please use `generateSecretASCII()` instead.');\n\n/**\n * Generate a Google Authenticator-compatible otpauth:// URL for passing the\n * secret to a mobile device to install the secret.\n *\n * Authenticator considers TOTP codes valid for 30 seconds. Additionally,\n * the app presents 6 digits codes to the user. According to the\n * documentation, the period and number of digits are currently ignored by\n * the app.\n *\n * To generate a suitable QR Code, pass the generated URL to a QR Code\n * generator, such as the `qr-image` module.\n *\n * @param {Object} options\n * @param {String} options.secret Shared secret key\n * @param {String} options.label Used to identify the account with which\n *   the secret key is associated, e.g. the user's email address.\n * @param {String} [options.type=\"totp\"] Either \"hotp\" or \"totp\".\n * @param {Integer} [options.counter] The initial counter value, required\n *   for HOTP.\n * @param {String} [options.issuer] The provider or service with which the\n *   secret key is associated.\n * @param {String} [options.algorithm=\"sha1\"] Hash algorithm (sha1, sha256,\n *   sha512).\n * @param {Integer} [options.digits=6] The number of digits for the one-time\n *   passcode. Currently ignored by Google Authenticator.\n * @param {Integer} [options.period=30] The length of time for which a TOTP\n *   code will be valid, in seconds. Currently ignored by Google\n *   Authenticator.\n * @param {String} [options.encoding] Key encoding (ascii, hex, base32,\n *   base64). If the key is not encoded in Base-32, it will be reencoded.\n * @return {String} A URL suitable for use with the Google Authenticator.\n * @throws Error if secret or label is missing, or if hotp is used and a\n    counter is missing, if the type is not one of `hotp` or `totp`, if the\n    number of digits is non-numeric, or an invalid period is used. Warns if\n    the number of digits is not either 6 or 8 (though 6 is the only one\n    supported by Google Authenticator), and if the hashihng algorithm is\n    not one of the supported SHA1, SHA256, or SHA512.\n * @see https://github.com/google/google-authenticator/wiki/Key-Uri-Format\n */\n\nexports.otpauthURL = function otpauthURL (options) {\n  // unpack options\n  var secret = options.secret;\n  var label = options.label;\n  var issuer = options.issuer;\n  var type = (options.type || 'totp').toLowerCase();\n  var counter = options.counter;\n  var algorithm = (options.algorithm || 'sha1').toLowerCase();\n  var digits = options.digits || 6;\n  var period = options.period || 30;\n  var encoding = options.encoding || 'ascii';\n\n  // validate type\n  switch (type) {\n    case 'totp':\n    case 'hotp':\n      break;\n    default:\n      throw new Error('Speakeasy - otpauthURL - Invalid type `' + type + '`; must be `hotp` or `totp`');\n  }\n\n  // validate required options\n  if (!secret) throw new Error('Speakeasy - otpauthURL - Missing secret');\n  if (!label) throw new Error('Speakeasy - otpauthURL - Missing label');\n\n  // require counter for HOTP\n  if (type === 'hotp' && (counter === null || typeof counter === 'undefined')) {\n    throw new Error('Speakeasy - otpauthURL - Missing counter value for HOTP');\n  }\n\n  // convert secret to base32\n  if (encoding !== 'base32') secret = new Buffer(secret, encoding);\n  if (Buffer.isBuffer(secret)) secret = base32.encode(secret);\n\n  // build query while validating\n  var query = {secret: secret};\n  if (issuer) query.issuer = issuer;\n  if (type === 'hotp') {\n    query.counter = counter;\n  }\n\n  // validate algorithm\n  if (algorithm != null) {\n    switch (algorithm.toUpperCase()) {\n      case 'SHA1':\n      case 'SHA256':\n      case 'SHA512':\n        break;\n      default:\n        console.warn('Speakeasy - otpauthURL - Warning - Algorithm generally should be SHA1, SHA256, or SHA512');\n    }\n    query.algorithm = algorithm.toUpperCase();\n  }\n\n  // validate digits\n  if (digits != null) {\n    if (isNaN(digits)) {\n      throw new Error('Speakeasy - otpauthURL - Invalid digits `' + digits + '`');\n    } else {\n      switch (parseInt(digits, 10)) {\n        case 6:\n        case 8:\n          break;\n        default:\n          console.warn('Speakeasy - otpauthURL - Warning - Digits generally should be either 6 or 8');\n      }\n    }\n    query.digits = digits;\n  }\n\n  // validate period\n  if (period != null) {\n    period = parseInt(period, 10);\n    if (~~period !== period) {\n      throw new Error('Speakeasy - otpauthURL - Invalid period `' + period + '`');\n    }\n    query.period = period;\n  }\n\n  // return url\n  return url.format({\n    protocol: 'otpauth',\n    slashes: true,\n    hostname: type,\n    pathname: encodeURIComponent(label),\n    query: query\n  });\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}